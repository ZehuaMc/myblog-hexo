---
title: 2024.1.19-1.31总结
date: 2024-02-01 01:37:00
updated: 2024-02-01 01:37:00
tags:
---
# 完成Verilog oj

[hide-block name="oj截图"]![2024-01-31T16:34:32.png][1][/hide-block]

# ECC纠错
## 原理
### 纠正1位错
下图是一个16bit的数据，用2号数据对右半边数据奇偶校验（有奇数个1则为1，偶数个1则为0），若数据存在1位错误，通过计数右半边数据中1的个数，即可确定错误在哪一半边。
哪一边确定了，那还需要确定数据在哪一列。使用1号数据，对2，4列进行奇偶校验，结合2号数据的检验结果，即可确定数据在哪一列。
列确定了，还需要确定行。重复上述步骤，使用8号数据对3，4行奇偶校验，4号数据对2，4行奇偶校验，即可确定哪一位数据出错
![2024-01-31T16:35:30.png][2]
### 更进一步，纠正1位错，验出2位错
矩阵中的第0号位，没有被任何的检验位检验，可以用0号数据对之后的全部数据进行奇偶检验。
有以下几种情况
 1. 0号位没有检测出错误，局部数据检验的检验位也没有检测出错误，则无错误。
 1. 0号位没有检测出错误，但是用作局部数据检验的检验位检测出错误，则存在2个错误。
 2. 0号位检测出错误，则存在1位错误或者3位错误。
### 换个视角
![2024-01-31T17:15:00.png][3]
数据的检验位都是二的幂次方的位
1号检验位位覆盖了所有数据位位置序号的二进制表示倒数第一位是1的数据：0001（校验位自身，这里都是二进制，下同），0011，0101，0111，1001。
2号检验位覆盖了所有数据位位置序号的二进制表示倒数第二位是1的数据：0010（校验位自身），0011，0110，0111，1010，1011，等。
4号检验位覆盖了所有数据位位置序号的二进制表示倒数第三位是1的数据：0100（校验位自身），0101，0110，0111，1100，1101，1110，1111。
8号检验位覆盖了所有数据位位置序号的二进制表示倒数第四位是1的数据：1000（校验位自身），1001，1010，1011，1100，1101，1110，1111。
简而言之，所有校验位覆盖了数据位置和该校验位位置的二进制与的值不为0的数。
# 更强大的纠错方法 LDPC
数学没学到这部分，看不懂了
参考资料：https://zhuanlan.zhihu.com/p/514670102
https://zlearning.netlify.app/communication/ecc/ldpc-introduction
https://zh.wikipedia.org/wiki/%E4%BD%8E%E5%AF%86%E5%BA%A6%E5%A5%87%E5%81%B6%E6%AA%A2%E6%9F%A5%E7%A2%BC
# 内存刷洗
参考资料：https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E5%88%B7%E6%B4%97
周期的从sram中读取数据，然后通过ecc纠错再写回。

> 内存刷洗（英语：Memory scrubbing）也可称内存擦洗、内存清洗，是指从每个电脑存储器位置读取数据、以一种错误纠错码（ECC）纠正可能存在的比特错误，再将校正后的数据写回原位置。
> 由于现代计算机内存芯片的高度集成，单个内存单元的结构已足够小到易于受到宇宙射线和/或阿尔法粒子的影响。由这些现象引发的错误被称为软性错误，这对基于DRAM或SRAM的内存来说可能是个问题。在任何单个内存比特发生软错误的概率非常小。但是，配以现代计算机的庞大内存空间，加之长时间持续运行的如服务器，在已安装内存中发生软错误的概率可能比较显著


  [1]: https://image.200502.xyz/i/2025/01/29/o1yxn2-0.webp
  [2]: https://image.200502.xyz/i/2025/01/29/o1zrpf-0.webp
  [3]: https://image.200502.xyz/i/2025/01/29/o20f9u-0.webp