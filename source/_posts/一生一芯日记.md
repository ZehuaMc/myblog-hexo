---
title: 一生一芯日记
date: 2025-01-26 22:22:00
updated: 2025-02-01 20:30:00
tags:
---
记录下一生一芯的学习过程
# 理解mainargs
![image-20250130205522617](https://image.200502.xyz/i/2025/01/30/xzmbzg-0.webp)在nemu中，mainargs是通过am/src/platform/nemu/trm.c中的_trm_init()函数传递给main()函数的（在这里调用了main()函数）。在trm.c中定义了mainargs数组，并且在scripts/platform/nemu.mk中通过CFLAGS += -DMAINARGS=\"$(mainargs)\"宏定义了mainargs是什么。
在npc中，mainargs是通过在am/src/native/platform.c中的init_platform()传递给main函数的（在这里调用了main()函数）。这里通过getenv("mainargs")这个函数获取到了mainargs。

# 实现printf
![image-20250130205536885](https://image.200502.xyz/i/2025/01/30/xzpdxq-0.webp)为了复用之前实现sprintf的代码，把大部分sprintf的功能实现放到了vsprintf中，在sprintf中建立好va_list传入就重新实现了sprintf,printf同样，建好va_list传入sprintf就行。
数字转字符串的函数有点问题，没有考虑INT_MIN（我直接把数字加个符号拿去%10了)，重写了一遍这个函数，单独考虑了INT_MIN。

# 实现IOE

![image-20250130210554582](https://image.200502.xyz/i/2025/01/30/ytkvkt-0.webp)nemu中每次访问设备，都会调用每个设备的回调函数，去更新时间的寄存器。在rtc的测试中，io_read()会访问指定的设备寄存器，匹配到AM_TIMER_UPTIME寄存器后，会调用__am_timer_uptime()去访问内存读取时间。

需要先访问高位内存，nemu中访问高位内存后才去更新时间的内存地址。

# 看看NEMU跑多快

跑的时候竟然发现nemu的slt和lb指令没有实现

![image-20250130211011101](https://image.200502.xyz/i/2025/01/30/ywaoeg-0.webp)

![image-20250130231420800](https://image.200502.xyz/i/2025/01/30/129t6pu-0.webp)![image-20250131152413121](https://image.200502.xyz/i/2025/01/31/p7es7g-0.webp)![image-20250131152446896](https://image.200502.xyz/i/2025/01/31/p7m8nn-0.webp)![image-20250131152611405](https://image.200502.xyz/i/2025/01/31/p8l9ou-0.webp)

# 实现malloc()

malloc()从heap中分配内存，heap的起始地址是`extern char _heap_start`指定的，_heap_start的值是在链接脚本中给的。

根据RTFM，malloc()要求返回的内存地址必须适合于在该平台上任意数据类型的对齐要求；所以我采取了8字节对齐。

# native与klib

![image-20250201183444110](https://image.200502.xyz/i/2025/02/01/uc5tyf-0.webp)

在native.mk中`g++ -pie -o $(IMAGE) -Wl,--whole-archive $(LINKAGE) -Wl,-no-whole-archive $(LDFLAGS_CXX) -lSDL2 -ldl`，SDL2库是被动态链接上的，所以当程序运行的时候，SDL2会被链接上glibc的函数，而不是klib中的。

# dtrace

跟mtrace差不多

